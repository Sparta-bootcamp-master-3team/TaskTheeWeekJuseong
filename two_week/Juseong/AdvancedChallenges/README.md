# AdvancedChallenges

이 프로젝트는 내일배움캠프 iOS 마스터 6기 3주차 심화 과제 구현 내용을 담고 있다.  
과제는 Swift 언어를 이용하여 클로저, 고차함수, 제네릭 함수 및 객체 지향 설계 등을 다루고 있으며, 각 문제별 구현 내용은 아래와 같다.

<br>

## 프로젝트 구조
```
📦 AdvancedChallenges
├── 📂 AdvancedChallenges
│   ├── main.swift        // 문제 결과 출력
│   ├── Problem1.swift    // 필수 문제 1
│   ├── Problem2.swift    // 필수 문제 2
│   ├── Problem3.swift    // 필수 문제 3
│   ├── Problem4.swift    // 도전 문제 1
└── README.md
```
<br>

## 과제 내용 및 구현

### 필수 문제 1 – 클로저와 함수 설계

#### 클로저 설계  
- 두 개의 `Int` 값을 파라미터로 받고 두 수를 더한 후, `"두 수의 합은 {합계} 입니다"`라는 문자열을 반환하는 클로저를 정의하였다.
- 이 클로저는 상수 sum에 저장되며, 타입이 명시되어 있다.
  
#### 클로저 호출 
- `sum`을 호출하여 임의의 정수 값을 전달한 후, 결과를 확인할 수 있도록 코드를 작성하였다.
  
#### 함수 calculate 
- `sum`과 동일한 타입의 클로저를 파라미터로 받아 내부에서 해당 클로저를 호출하는 반환 값이 없는 함수 `calculate`를 구현하였다.

---

### 필수 문제 2 – 고차함수와 커스텀 map 구현

#### forEach → map 변환 
- 기존의 forEach 문을 map 함수를 사용하여 간결하게 변환하였다.
  
#### 고차함수 체이닝
- 입력 배열 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` 에 대해 `map`과 `filter`를 체이닝하여 짝수만 추출한 후 문자열 배열 `["2", "4", "6", "8", "10"]`를 반환하는 코드를 작성하였다.
  
#### 커스텀 함수 `myMap` 구현 
- 정수 배열을 입력받아 문자열 배열로 변환하는 고차함수 `myMap`을 구현하였다.
  
- 예시:
  ```swift
  let result = myMap([1, 2, 3, 4, 5]) {
      String($0)
  }
  print(result) // ["1", "2", "3", "4", "5"]
  ```

---

### 필수 문제 3 – 제네릭과 프로토콜

#### 함수 `a`  
- `Int` 배열에서 짝수번째(인덱스 기준 1, 3, 5, …) 요소를 제거하여 반환하는 함수를 구현하였다.  
- 예) 입력: `[1, 2, 3, 4, 5]` → 출력: `[1, 3, 5]`
  
#### 함수 `b`
- `String` 배열에 대해서도 동일하게 짝수번째 요소를 제거하는 함수를 구현하였다.  
- 예) 입력: `["가", "나", "다", "라", "마"]` → 출력: `["가", "다", "마"]`
  
#### 함수 `c` – 제네릭 함수
- 위의 두 함수를 하나로 통합하여 배열의 요소 타입에 상관없이 짝수번째 요소를 제거하는 제네릭 함수 `c`를 구현하였다.  
  
#### 함수 `d` – Numeric 프로토콜 확장
- 함수 `c`를 기반으로 파라미터의 타입을 'Numeric 프로토콜'을 준수하는 요소 배열로 확장한 함수 `d`를 구현하였습니다.

---

### 도전 문제 1 – 객체 지향 설계: 자동차

#### 1. Engine 및 서브클래스
- **Engine**  
  - 기본 엔진 클래스로, 엔진 타입을 "일반"으로 반환한다.
- **ElectricEngine**  
  - `Engine`을 상속받아 엔진 타입을 "전기"로 오버라이드한 클래스이다.
- **HydrogenEngine**  
  - `Engine`을 상속받아 엔진 타입을 "수소"로 오버라이드한 클래스이다.

#### 2. Car 클래스
- **Car**  
  - 자동차의 기본 정보를 담고 있으며, 다음의 상태를 가진다:
    - `brand`, `model`, `year`: `String` 타입
    - `engine`: 엔진을 나타내는 `Engine` 타입
  - **동작**: `drive()` 메서드를 통해 “[브랜드] [모델] 주행중” 메시지를 출력한다.

#### 3. ElectricCar 및 HybridCar 클래스
- **ElectricCar**  
  - `Car`를 상속받으며, `ElectricEngine` 타입의 엔진을 사용한다.
- **HybridCar**  
  - `Car`를 상속받으며, `HydrogenEngine` 타입의 엔진을 사용한다.
  - **추가 동작**: `switchEngine(to:)` 메서드를 통해 런타임에 엔진을 변경할 수 있도록 구현하였다.

#### 4. 상속과 프로토콜 비교 (코드 내 주석 참고)
**상속**
- *장점*: 코드 재사용성이 높으며, 오버라이딩을 통해 세부 기능을 쉽게 수정할 수 있다.
- *단점*: 하나의 클래스만 상속할 수 있어 다중 상속이 불가능하며, 클래스에서만 적용 가능하다.

**프로토콜**
- *장점*: 여러 프로토콜을 채택해 유연하게 기능을 조합할 수 있으며, 모든 타입에서 채택할 수 있다.
- *단점*: 기본 구현이 없는 경우 모든 요구사항을 직접 구현해야 하며, 지나치게 많은 프로토콜 분리는 가독성과 유지보수를 어렵게 할 수 있다.
